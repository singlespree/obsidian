---
создал заметку: 2024-06-30
---
Это мощный и гибкий инструмент для работы с последовательностями элементов. Они представляют более удобный способ работы с [[Массив]], предоставляя динамическую длину, возможность изменения размера и различные удобные функции для манипуляций. 

### Основные свойства срезов
1. [[Длина]] и [[Ёмкость]] срезов:
- Длина - количество элементов в срезе
- Ёмкость - количество элементов в базовом массиве, начиная с первого элемента среза. 
2. Срезы являются окнами на [[Массив]]:
- Срезы не хранят сами элементы, они ссылаются на базовый массив. 
- Срез может указывать на часть массива или же на весь массив
3. Срезы имеют динамическую длину: 
- В отличие от массивов, длина среза может изменяться во время выполнения программы. 
4. Zero value: 
- Нулевое значение для среза - это [[nil]]. Срез с нулевым значением не содержит элементов и имеет длину и ёмкость, равные 0.

### Создание срезов
1. Срезы из массивов можно создавать из существующего массива. 
```
arr := [5]int{1, 2, 3, 4, 5}
   s := arr[1:4]  // Создание среза, который содержит элементы с индексами 1, 2 и 3
   fmt.Println(s) // [2 3 4]
```

2. С помощью функции `make` можно создавать срезы с заданной длиной и ёмкость. 
```
 s := make([]int, 5)       // Создание среза длиной 5 и ёмкость 5
   fmt.Println(s)            // [0 0 0 0 0]
   
   s2 := make([]int, 3, 5)   // Создание среза длиной 3 и ёмкостью 5
   fmt.Println(s2)           // [0 0 0]
```

3. Литерал среза. Можно инициализировать с использованием литералов
```
s := []int{1, 2, 3, 4, 5}
   fmt.Println(s) // [1 2 3 4 5]
```

### Встроенные функции для срезов

1. `len` возвращает длину среза
`fmt.Println(len(s)) // 5`

2. `cap` возвращает [[Ёмкость]] среза
`fmt.Println(cap(s)) // 5`

### Операции над срезами
1. Изменение длины среза. Срезы могут быть изменены, создав новый срез, указывающий на тот же массив.
```
 s = s[:2]    // Срезаем длину до 2
   fmt.Println(s)    // [1 10]
   
   s = s[:4]    // Расширяем длину до 4
   fmt.Println(s)    // [1 10 3 4]
   
   s = s[2:]    // Удаляем первые два элемента
   fmt.Println(s)    // [3 4]
```

2. Добавление элементов. Функция [[append]] добавляет новые элементы к срезу, если недостаточно ёмкости, создаётся новый базовый массив.
```
 s := []int{1, 2}
   s = append(s, 3, 4, 5)
   fmt.Println(s)  // [1 2 3 4 5]
```

3. Копирование срезов. Функция [[copy]] копирует элементы из одного среза в другой. Количество скопированных элементов будет минимальным из длины `src` и `dst`
```
src := []int{1, 2, 3}
   dst := make([]int, 2)
   copy(dst, src)
   fmt.Println(dst)  // [1 2]
```

### Nil срезы и сравнение

1. Nil срезы имеют длину и ёмкость, равные 0, и не ссылаются на базовый массив. 

```
var s []int
   fmt.Println(s, len(s), cap(s))  // [] 0 0
   if s == nil {
       fmt.Println("nil!")        // nil!
   }
```

2. Срезы можно сравнивать только с [[nil]]. Для проверки одинаковых элементов или длины срезов используйте цикл или пакет [[reflect]] 

### Примеры использования

Срезы часто используются для различных манипуляций с данными благодаря своей гибкости. 
- Обработка массивов данных
- Динамическое изменение длины последовательностей
- Использование мощных функций для сортировки, фильтрации и пр.

Срезы в Go являются мощным инструментов для эффективной работы с последовательностями данных, предоставляя удобный интерфейс для управления и модификации элементов. 