---
создал заметку: 2024-06-30
Url: https://tour.ardanlabs.com/tour/rus/struct-types/1
---
### Типы данных struct используются для создания сложных типов, группирующих несколько полей.
Потенциальная производительность архитектуры компьютера в значительной степени определяется её длиной слов(количеством битов, которые будут обработаны за одну операцию) и размером памяти, или количеством слов, к которым она может получить доступ

### Структуры и механика их создания
Объявление представляет конкретный определенный пользователем тип в виде композита полей и типов. 
`type example struct { 
	`flag bool` 
	`countr int16`
	`pi float 32` 
`}`

### Объявление переменной типа example с помощью литерального синтаксиса инициализации(не устанавливает нулевое значение)

`e2 := example {`
	`flag: true,`
	`counter: 10,`
	`pi: 3.14592,`
`}`

### Объявление переменной безымянного литерального типа в состояние ненулевого значения с использованием литерального синтаксиса инициализации.

`e3 := struct {`
	`flag bool`
	`counter int16`
	`pi float32`
`}{`
	`flag: true,`
	`counter: 10,`
	`pi: 3.141592,`
`}`

### Следует использовать `var` для задания нулевого значения и оператор короткого объявления переменной с синтаксисом `{}` для задания ненулевого значения.

# Выравнивание и Заполнение

### Выравнивание - это способ размещения данных в памяти таким образом, чтобы доступ к ним был максимально эффективным. Процессоры быстрее работают с данными, если они выровнены по определенным границам в памяти. 

`type example struct {
    `flag    bool` 1 байт
    `counter int16` 2 байта
    `pi      float32` 4 байта
`}`
Если сложить всё это вместе, будет 7 байт, но фактически 8 байт, потому что между полями `flag` и `counter` находится дополнительный байт для выравнивания
![[Pasted image 20240630111324.png]]
Идея выравнивания заключается в том, чтобы позволить компьютеру, более эффективно считывать память, размещая значения на определенных границах выравнивания памяти. Компилятор заботится о механике границы выравнивания. 

В зависимости от размера конкретного поля и его местоположения в структуре Go определяет необходимые заполнения. 

## Пример структуры
`type Example struct { `
	`A int8 // 1 байт `
	`B int32 // 4 байта `
	`C int8 // 1 байт `
`}`
## Пример структуры с паддингом
`type Example struct {` 
	`A int8 // 1 байт` 
	`_ [3]byte // 3 байта паддинга `
	`B int32 // 4 байта` 
	`C int8 // 1 байт `
	`_ [3]byte // 3 байта паддинга для выравнивания структуры `
`}`
## Оптимизация структуры
`type OptimizedExample struct { `
	`B int32 // 4 байта `
	`A int8 // 1 байт `
	`C int8 // 1 байт `
	`_ [2]byte // 2 байта паддинга для выравнивания структуры `
`}`
## Итоговые размеры
Пример обычной структуры:  12 байт
Пример оптимизированной структуры: 8 байт

## Присвоение значений
Если у вас есть два разных именованных типа, идентичных по своей структуре, вы не можете присвоить значение одного другому. 
Например: если типы example 1 и example 2 имеют идентичную структуру и мы инициализируем две переменные. 
`var ex1 example1 var ex2 example2`
Вы не можете присвоить эти две переменные друг другу, так как они имеют разные именованные типы. Тот факт, что они идентичны по своей структуре, не имеет значения.
`ex1 = ex2 // запрещено, ошибка компиляции`

Для выполнения этого присвоения вам придется использовать преобразование, и поскольку они имеют одинаковую структуру, компилятор это позволит
`ex1 = example1(ex2) // разрешено, нет ошибки компиляции`
Однако, если `ex2` был объявлен, как [[анонимный тип]], объявленный идентично с ex1, преобразование не потребуется
`var ex2 struct {flag bool counter in16 pi float32`
`ex1 = ex2 // Разрешено, преобразование не требуется`

### Мы можем использовать структурный литерал для инициализации значения типа структуры.
### Оператор точки (.) позволяет нам получать доступ к значениям полей
### Мы можем создавать анонимные структуры. 