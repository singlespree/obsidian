---
создал заметку: 2024-06-30
---
### Горутина это легковесные потоки выполнения в языке Go. Они позволяют выполнять несколько задач одновременно, что делает программы более быстрыми и эффективными.
Горутина запускается с помощью ключевого слова `go`
Когда вы добавляете `go` перед вызовом функции, эта функция начинает выполняться в отдельной горутине.

### Пример:
```
func main() {
    go sayHello() // Запуск функции в горутине
    time.Sleep(1 * time.Second) // Ожидание, чтобы горутина успела завершиться
}
```

В этом примере функция `sayHello` запускается в отдельной горутине. Основная программа ждет 1 секунду, чтобы горутина успела завершить выполнение. 

## Доп. примеры
1. Запуск нескольких горутин
```
package main

import (
    "fmt"
    "time"
)

func printNumbers() {
    for i := 1; i <= 5; i++ {
        fmt.Println(i)
        time.Sleep(500 * time.Millisecond)
    }
}

func main() {
    go printNumbers() // Запуск первой горутины
    go printNumbers() // Запуск второй горутины
    time.Sleep(3 * time.Second) // Ожидание, чтобы обе горутины успели завершиться
}
```
 2. Синхронизация горутин с помощью `sync.WaitGroup`:
 ```
package main

import (
    "fmt"
    "sync"
)

func sayHello(wg *sync.WaitGroup) {
    defer wg.Done() // Уменьшение счетчика горутин
    fmt.Println("Hello, world!")
}

func main() {
    var wg sync.WaitGroup

    wg.Add(1) // Увеличение счетчика горутин
    go sayHello(&wg)

    wg.Wait() // Ожидание завершения всех горутин
}
```

### Каждой горутине отводится свой блок памяти, называемый [[Стек]]. При создании, под стек выделяется `2048 байт (2к) памяти`. Это очень немного, но со временем стек может увеличиваться в размерах. 

![[Pasted image 20240630124808.png]]

Каждый раз, при вызове функции, под выполнение инструкций, связанных с этой функцией, горутине на стеке выделяется блок памяти. Каждый такой блок называется [[Фрейм]]

Размер [[Фрейм]] для каждой функции определяется при компиляции. Значение не может быть создано на [[Стек]], если на этапе компиляции компилятор не знает размера этого значения. Если компилятор не знает размера значения на этапе компиляции, значение вынужденно создается на [[Куча]]
